using Microsoft.CodeAnalysis;

namespace SilentOrbit.ProtocolBuffers.Code;

internal class ProtoCode
{
    private GeneratorExecutionContext context;

    public ProtoCode(GeneratorExecutionContext context)
    {
        this.context = context;
    }

    void AddSource(string fullType, CodeWriter cw)
    {
        if (fullType.StartsWith("global::"))
            fullType = fullType.Substring("global::".Length);

        context.AddSource(fullType + ".g.cs", cw.Code);
    }

    static CodeWriter GenerateFileHeader()
    {
        var cw = new CodeWriter();

        cw.WriteLine();
        cw.Comment(@"Generated by ProtocolBuffer
- a pure c# code generation implementation of protocol buffers
Report bugs to: https://silentorbit.com/protobuf/");
        cw.WriteLine();
        cw.Comment(@"DO NOT EDIT
This file will be overwritten when CodeGenerator is run.
To make custom modifications, edit the .proto file and add //:external before the message line
then write the code and the changes in a separate file.");
        cw.WriteLine();
        cw.WriteLine("using System;");
        cw.WriteLine("using System.IO;");
        cw.WriteLine("using System.Text;");
        cw.WriteLine("using System.Collections.Generic;");
        cw.WriteLine();
        cw.WriteLine("using SilentOrbit.ProtocolBuffers;");
        cw.WriteLine("using static SilentOrbit.ProtocolBuffers.ProtocolParser;");
        cw.WriteLine();

        return cw;
    }

    /// <summary>
    /// Generate code for reading and writing protocol buffer messages
    /// </summary>
    public void Save(ProtoCollection file)
    {
        //Basic structures

        foreach (var m in file.Messages.Values)
        {
            if (m.OptionExternal)
                continue;

            using var cw = GenerateFileHeader();
            cw.Comment("Classes and structures being serialized");

            cw.WriteLine("namespace " + m.CsNamespace + ";");
            cw.WriteLine();

            new MessageCode(cw).GenerateClass(m);
            cw.WriteLine();

            AddSource(m.FullProtoName, cw);
        }

        foreach (var e in file.Enums.Values)
        {
            if (e.OptionExternal)
                continue;

            using var cw = GenerateFileHeader();
            cw.Comment("Classes and structures being serialized");

            cw.WriteLine("namespace " + e.CsNamespace + ";");
            cw.WriteLine();

            new MessageCode(cw).GenerateEnum(e);
            cw.WriteLine();

            AddSource(e.FullProtoName, cw);
        }

        //.Serializer.cs
        //Code for Reading/Writing
        foreach (var m in file.Messages.Values)
        {
            using var cw = GenerateFileHeader();
            cw.Comment("This is the backend code for reading and writing");

            cw.WriteLine("namespace " + m.CsNamespace + ";");
            cw.WriteLine();

            var messageSerializer = new MessageSerializer(cw);
            messageSerializer.GenerateClassSerializer(m);

            AddSource(m.FullCsType + ".Serializer", cw);
        }

    }

}
