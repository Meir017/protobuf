﻿
// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
// To make custom modifications, edit the .proto file and add //:external before the message line
// then write the code and the changes in a separate file.

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

using SilentOrbit.ProtocolBuffers;
using static SilentOrbit.ProtocolBuffers.ProtocolParser;

// Classes and structures being serialized
namespace Google.Protobuf;

public partial class FieldOptions
{
    public FieldOptions()
    {
        Ctype = global::Google.Protobuf.FieldOptions.CType.STRING;
        Lazy = false;
        Deprecated = false;
        Weak = false;
    }
    public enum CType
    {
        /// <summary> Default mode.</summary>
        STRING = 0,
        CORD = 1,
        STRING_PIECE = 2,
    }

    /// <summary>
    /// <para> The ctype option instructs the C++ code generator to use a different</para>
    /// <para> representation of the field than it normally would.  See the specific</para>
    /// <para> options below.  This option is not yet implemented in the open source</para>
    /// <para> release -- sorry, we'll try to include it in a future version!</para>
    /// </summary>
    public global::Google.Protobuf.FieldOptions.CType Ctype { get; set; }

    /// <summary>
    /// <para> The packed option can be enabled for repeated primitive fields to enable</para>
    /// <para> a more efficient representation on the wire. Rather than repeatedly</para>
    /// <para> writing the tag and type for each element, the entire array is encoded as</para>
    /// <para> a single length-delimited blob.</para>
    /// </summary>
    public bool Packed { get; set; }

    /// <summary>
    /// <para> Should this field be parsed lazily?  Lazy applies only to message-type</para>
    /// <para> fields.  It means that when the outer message is initially parsed, the</para>
    /// <para> inner message's contents will not be parsed but instead stored in encoded</para>
    /// <para> form.  The inner message will actually be parsed when it is first accessed.</para>
    /// <para></para>
    /// <para> This is only a hint.  Implementations are free to choose whether to use</para>
    /// <para> eager or lazy parsing regardless of the value of this option.  However,</para>
    /// <para> setting this option true suggests that the protocol author believes that</para>
    /// <para> using lazy parsing on this field is worth the additional bookkeeping</para>
    /// <para> overhead typically needed to implement it.</para>
    /// <para></para>
    /// <para> This option does not affect the public interface of any generated code;</para>
    /// <para> all method signatures remain the same.  Furthermore, thread-safety of the</para>
    /// <para> interface is not affected by this option; const methods remain safe to</para>
    /// <para> call from multiple threads concurrently, while non-const methods continue</para>
    /// <para> to require exclusive access.</para>
    /// <para></para>
    /// <para></para>
    /// <para> Note that implementations may choose not to check required fields within</para>
    /// <para> a lazy sub-message.  That is, calling IsInitialized() on the outher message</para>
    /// <para> may return true even if the inner message has missing required fields.</para>
    /// <para> This is necessary because otherwise the inner message would have to be</para>
    /// <para> parsed in order to perform the check, defeating the purpose of lazy</para>
    /// <para> parsing.  An implementation which chooses not to check required fields</para>
    /// <para> must be consistent about it.  That is, for any particular sub-message, the</para>
    /// <para> implementation must either *always* check its required fields, or *never*</para>
    /// <para> check its required fields, regardless of whether or not the message has</para>
    /// <para> been parsed.</para>
    /// </summary>
    public bool Lazy { get; set; }

    /// <summary>
    /// <para> Is this field deprecated?</para>
    /// <para> Depending on the target platform, this can emit Deprecated annotations</para>
    /// <para> for accessors, or it will be completely ignored; in the very least, this</para>
    /// <para> is a formalization for deprecating fields.</para>
    /// </summary>
    public bool Deprecated { get; set; }

    /// <summary>
    /// <para> EXPERIMENTAL.  DO NOT USE.</para>
    /// <para> For "map" fields, the name of the field in the enclosed type that</para>
    /// <para> is the key for this map.  For example, suppose we have:</para>
    /// <para>   message Item {</para>
    /// <para>     required string name = 1;</para>
    /// <para>     required string value = 2;</para>
    /// <para>   }</para>
    /// <para>   message Config {</para>
    /// <para>     repeated Item items = 1 [experimental_map_key="name"];</para>
    /// <para>   }</para>
    /// <para> In this situation, the map key for Item will be set to "name".</para>
    /// <para> TODO: Fully-implement this, then remove the "experimental_" prefix.</para>
    /// </summary>
    public string ExperimentalMapKey { get; set; }

    /// <summary> For Google-internal migration only. Do not use.</summary>
    public bool Weak { get; set; }

    /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
    public List<UninterpretedOption> UninterpretedOption { get; set; }

}

