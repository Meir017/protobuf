﻿
// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
// To make custom modifications, edit the .proto file and add //:external before the message line
// then write the code and the changes in a separate file.

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

using SilentOrbit.ProtocolBuffers;
using static SilentOrbit.ProtocolBuffers.ProtocolParser;

// Classes and structures being serialized
namespace Google.Protobuf;

/// <summary>
/// <para> ===================================================================</para>
/// <para> Options</para>
/// <para> Each of the definitions above may have "options" attached.  These are</para>
/// <para> just annotations which may cause code to be generated slightly differently</para>
/// <para> or may contain hints for code that manipulates protocol messages.</para>
/// <para></para>
/// <para> Clients may define custom options as extensions of the *Options messages.</para>
/// <para> These extensions may not yet be known at parsing time, so the parser cannot</para>
/// <para> store the values in them.  Instead it stores them in a field in the *Options</para>
/// <para> message called uninterpreted_option. This field must have the same name</para>
/// <para> across all *Options messages. We then use this field to populate the</para>
/// <para> extensions when we build a descriptor, at which point all protos have been</para>
/// <para> parsed and so all extensions are known.</para>
/// <para></para>
/// <para> Extension numbers for custom options may be chosen as follows:</para>
/// <para> * For options which will only be used within a single application or</para>
/// <para>   organization, or for experimental options, use field numbers 50000</para>
/// <para>   through 99999.  It is up to you to ensure that you do not use the</para>
/// <para>   same number for multiple options.</para>
/// <para> * For options which will be published and used publicly by multiple</para>
/// <para>   independent entities, e-mail protobuf-global-extension-registry@google.com</para>
/// <para>   to reserve extension numbers. Simply provide your project name (e.g.</para>
/// <para>   Object-C plugin) and your porject website (if available) -- there's no need</para>
/// <para>   to explain how you intend to use them. Usually you only need one extension</para>
/// <para>   number. You can declare multiple options with only one extension number by</para>
/// <para>   putting them in a sub-message. See the Custom Options section of the docs</para>
/// <para>   for examples:</para>
/// <para>   http://code.google.com/apis/protocolbuffers/docs/proto.html#options</para>
/// <para>   If this turns out to be popular, a web service will be set up</para>
/// <para>   to automatically assign option numbers.</para>
/// </summary>
public partial class FileOptions
{
    public FileOptions()
    {
        JavaMultipleFiles = false;
        JavaGenerateEqualsAndHash = false;
        OptimizeFor = global::Google.Protobuf.FileOptions.OptimizeMode.SPEED;
        CcGenericServices = false;
        JavaGenericServices = false;
        PyGenericServices = false;
    }
    /// <summary> Generated classes can be optimized for speed or code size.</summary>
    public enum OptimizeMode
    {
        SPEED = 1,
        /// <summary>
        /// <para> Generate complete code for parsing, serialization,</para>
        /// <para> etc.</para>
        /// </summary>
        CODE_SIZE = 2,
        /// <summary> Use ReflectionOps to implement these methods.</summary>
        LITE_RUNTIME = 3,
    }

    /// <summary>
    /// <para> Sets the Java package where classes generated from this .proto will be</para>
    /// <para> placed.  By default, the proto package is used, but this is often</para>
    /// <para> inappropriate because proto packages do not normally start with backwards</para>
    /// <para> domain names.</para>
    /// </summary>
    public string JavaPackage { get; set; }

    /// <summary>
    /// <para> If set, all the classes from the .proto file are wrapped in a single</para>
    /// <para> outer class with the given name.  This applies to both Proto1</para>
    /// <para> (equivalent to the old "--one_java_file" option) and Proto2 (where</para>
    /// <para> a .proto always translates to a single class, but you may want to</para>
    /// <para> explicitly choose the class name).</para>
    /// </summary>
    public string JavaOuterClassname { get; set; }

    /// <summary>
    /// <para> If set true, then the Java code generator will generate a separate .java</para>
    /// <para> file for each top-level message, enum, and service defined in the .proto</para>
    /// <para> file.  Thus, these types will *not* be nested inside the outer class</para>
    /// <para> named by java_outer_classname.  However, the outer class will still be</para>
    /// <para> generated to contain the file's getDescriptor() method as well as any</para>
    /// <para> top-level extensions defined in the file.</para>
    /// </summary>
    public bool JavaMultipleFiles { get; set; }

    /// <summary>
    /// <para> If set true, then the Java code generator will generate equals() and</para>
    /// <para> hashCode() methods for all messages defined in the .proto file. This is</para>
    /// <para> purely a speed optimization, as the AbstractMessage base class includes</para>
    /// <para> reflection-based implementations of these methods.</para>
    /// </summary>
    public bool JavaGenerateEqualsAndHash { get; set; }

    /// <summary> Generate code using MessageLite and the lite runtime.</summary>
    public global::Google.Protobuf.FileOptions.OptimizeMode OptimizeFor { get; set; }

    /// <summary>
    /// <para> Sets the Go package where structs generated from this .proto will be</para>
    /// <para> placed.  There is no default.</para>
    /// </summary>
    public string GoPackage { get; set; }

    /// <summary>
    /// <para> Should generic services be generated in each language?  "Generic" services</para>
    /// <para> are not specific to any particular RPC system.  They are generated by the</para>
    /// <para> main code generators in each language (without additional plugins).</para>
    /// <para> Generic services were the only kind of service generation supported by</para>
    /// <para> early versions of proto2.</para>
    /// <para></para>
    /// <para> Generic services are now considered deprecated in favor of using plugins</para>
    /// <para> that generate code specific to your particular RPC system.  Therefore,</para>
    /// <para> these default to false.  Old code which depends on generic services should</para>
    /// <para> explicitly set them to true.</para>
    /// </summary>
    public bool CcGenericServices { get; set; }

    public bool JavaGenericServices { get; set; }

    public bool PyGenericServices { get; set; }

    /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
    public List<UninterpretedOption> UninterpretedOption { get; set; }

}

