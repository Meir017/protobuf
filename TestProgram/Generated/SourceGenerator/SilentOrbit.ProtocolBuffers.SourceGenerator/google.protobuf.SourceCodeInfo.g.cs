﻿
// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
// To make custom modifications, edit the .proto file and add //:external before the message line
// then write the code and the changes in a separate file.

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

using SilentOrbit.ProtocolBuffers;
using static SilentOrbit.ProtocolBuffers.ProtocolParser;

// Classes and structures being serialized
namespace Google.Protobuf;

/// <summary>
/// <para> ===================================================================</para>
/// <para> Optional source code info</para>
/// <para> Encapsulates information about the original source file from which a</para>
/// <para> FileDescriptorProto was generated.</para>
/// </summary>
public partial class SourceCodeInfo
{
    /// <summary>
    /// <para> A Location identifies a piece of source code in a .proto file which</para>
    /// <para> corresponds to a particular definition.  This information is intended</para>
    /// <para> to be useful to IDEs, code indexers, documentation generators, and similar</para>
    /// <para> tools.</para>
    /// <para></para>
    /// <para> For example, say we have a file like:</para>
    /// <para>   message Foo {</para>
    /// <para>     optional string foo = 1;</para>
    /// <para>   }</para>
    /// <para> Let's look at just the field definition:</para>
    /// <para>   optional string foo = 1;</para>
    /// <para>   ^       ^^     ^^  ^  ^^^</para>
    /// <para>   a       bc     de  f  ghi</para>
    /// <para> We have the following locations:</para>
    /// <para>   span   path               represents</para>
    /// <para>   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.</para>
    /// <para>   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).</para>
    /// <para>   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).</para>
    /// <para>   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).</para>
    /// <para>   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).</para>
    /// <para></para>
    /// <para> Notes:</para>
    /// <para> - A location may refer to a repeated field itself (i.e. not to any</para>
    /// <para>   particular index within it).  This is used whenever a set of elements are</para>
    /// <para>   logically enclosed in a single code segment.  For example, an entire</para>
    /// <para>   extend block (possibly containing multiple extension definitions) will</para>
    /// <para>   have an outer location whose path refers to the "extensions" repeated</para>
    /// <para>   field without an index.</para>
    /// <para> - Multiple locations may have the same path.  This happens when a single</para>
    /// <para>   logical declaration is spread out across multiple places.  The most</para>
    /// <para>   obvious example is the "extend" block again -- there may be multiple</para>
    /// <para>   extend blocks in the same scope, each of which will have the same path.</para>
    /// <para> - A location's span is not always a subset of its parent's span.  For</para>
    /// <para>   example, the "extendee" of an extension declaration appears at the</para>
    /// <para>   beginning of the "extend" block and is shared by all extensions within</para>
    /// <para>   the block.</para>
    /// <para> - Just because a location's span is a subset of some other location's span</para>
    /// <para>   does not mean that it is a descendent.  For example, a "group" defines</para>
    /// <para>   both a type and a field in a single declaration.  Thus, the locations</para>
    /// <para>   corresponding to the type and field and their components will overlap.</para>
    /// <para> - Code which tries to interpret locations should probably be designed to</para>
    /// <para>   ignore those that it doesn't understand, as more types of locations could</para>
    /// <para>   be recorded in the future.</para>
    /// </summary>
    public List<global::Google.Protobuf.SourceCodeInfo.Location> LocationField { get; set; }

    public partial class Location
    {
        /// <summary>
        /// <para> Identifies which part of the FileDescriptorProto was defined at this</para>
        /// <para> location.</para>
        /// <para></para>
        /// <para> Each element is a field number or an index.  They form a path from</para>
        /// <para> the root FileDescriptorProto to the place where the definition.  For</para>
        /// <para> example, this path:</para>
        /// <para>   [ 4, 3, 2, 7, 1 ]</para>
        /// <para> refers to:</para>
        /// <para>   file.message_type(3)  // 4, 3</para>
        /// <para>       .field(7)         // 2, 7</para>
        /// <para>       .name()           // 1</para>
        /// <para> This is because FileDescriptorProto.message_type has field number 4:</para>
        /// <para>   repeated DescriptorProto message_type = 4;</para>
        /// <para> and DescriptorProto.field has field number 2:</para>
        /// <para>   repeated FieldDescriptorProto field = 2;</para>
        /// <para> and FieldDescriptorProto.name has field number 1:</para>
        /// <para>   optional string name = 1;</para>
        /// <para></para>
        /// <para> Thus, the above path gives the location of a field name.  If we removed</para>
        /// <para> the last element:</para>
        /// <para>   [ 4, 3, 2, 7 ]</para>
        /// <para> this path refers to the whole field declaration (from the beginning</para>
        /// <para> of the label to the terminating semicolon).</para>
        /// </summary>
        public List<int> Path { get; set; }

        /// <summary>
        /// <para> Always has exactly three or four elements: start line, start column,</para>
        /// <para> end line (optional, otherwise assumed same as start line), end column.</para>
        /// <para> These are packed into a single field for efficiency.  Note that line</para>
        /// <para> and column numbers are zero-based -- typically you will want to add</para>
        /// <para> 1 to each before displaying to a user.</para>
        /// </summary>
        public List<int> Span { get; set; }

        /// <summary>
        /// <para> If this SourceCodeInfo represents a complete declaration, these are any</para>
        /// <para> comments appearing before and after the declaration which appear to be</para>
        /// <para> attached to the declaration.</para>
        /// <para></para>
        /// <para> A series of line comments appearing on consecutive lines, with no other</para>
        /// <para> tokens appearing on those lines, will be treated as a single comment.</para>
        /// <para></para>
        /// <para> Only the comment content is provided; comment markers (e.g. //) are</para>
        /// <para> stripped out.  For block comments, leading whitespace and an asterisk</para>
        /// <para> will be stripped from the beginning of each line other than the first.</para>
        /// <para> Newlines are included in the output.</para>
        /// <para></para>
        /// <para> Examples:</para>
        /// <para></para>
        /// <para>   optional int32 foo = 1;  // Comment attached to foo.</para>
        /// <para>   // Comment attached to bar.</para>
        /// <para>   optional int32 bar = 2;</para>
        /// <para></para>
        /// <para>   optional string baz = 3;</para>
        /// <para>   // Comment attached to baz.</para>
        /// <para>   // Another line attached to baz.</para>
        /// <para></para>
        /// <para>   // Comment attached to qux.</para>
        /// <para>   //</para>
        /// <para>   // Another line attached to qux.</para>
        /// <para>   optional double qux = 4;</para>
        /// <para></para>
        /// <para>   optional string corge = 5;</para>
        /// <para>   /* Block comment attached</para>
        /// <para>    * to corge.  Leading asterisks</para>
        /// <para>    * will be removed. */</para>
        /// <para>   /* Block comment attached to</para>
        /// <para>    * grault. */</para>
        /// <para>   optional int32 grault = 6;</para>
        /// </summary>
        public string LeadingComments { get; set; }

        public string TrailingComments { get; set; }

    }

}

